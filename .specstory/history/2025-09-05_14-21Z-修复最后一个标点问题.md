<!-- Generated by SpecStory -->

# 修复最后一个标点问题 (2025-09-05 14:21Z)

_**User (2025-09-04 22:37Z)**_

最后一个不能有",",请修复

---

_**Assistant**_

我看到问题了！在 `toArgumentString` 方法中，最后一个元素后面会多一个逗号。让我修复这个问题：


---

Read file: src/test/java/com/jmix/configengine/scenario/base/StructCodeInjector.java

---

确实，这里每个元素后面都加了 `", "`，导致最后一个元素后面也会有多余的逗号。我来修复这个问题：

```java:src/test/java/com/jmix/configengine/scenario/base/StructCodeInjector.java
    private String toArgumentString(List<String> filterCodes) {
        StringBuilder sb = new StringBuilder();
        sb.append("Arrays.asList(");
        for (int i = 0; i < filterCodes.size(); i++) {
            sb.append("\"").append(filterCodes.get(i)).append("\"");
            if (i < filterCodes.size() - 1) {
                sb.append(", ");
            }
        }
        sb.append(")");
        return sb.toString();
    }
```

修复说明：
- 使用索引循环而不是增强for循环
- 只在不是最后一个元素时才添加逗号和空格
- 这样生成的字符串就不会有多余的逗号了

例如，如果 `filterCodes` 是 `["code1", "code2", "code3"]`，现在会生成：
```
Arrays.asList("code1", "code2", "code3")
```

而不是之前的：
```
Arrays.asList("code1", "code2", "code3", )
```

---

_**User (2025-09-05 14:23Z)**_

选择代码是实现Require的，现在要实现Codependent，请修改， Codependent的定义如下：  \n             //A=(a1,a2,a3,a4)
            //B=(b1,b2,b3,b4)
            // 规则内容：(a1,a3) CoDependent (b1,b2,b3)
            // 解读：
            // 1、正向
            // 1.1 如果AVar.var=a1,则BVar.var=b1 或 b2 或 b3
            // 1.2 如果AVar.var=a1,则BVar.var=b4，是不合法的
            // 2.反向 
            // 2.1 如果BVar.var=b1,则AVar.var=a1 或 a3 (a2,a4 不合法)
            // 2.2 如果BVar.var=b4,则AVar.var=a2 或 a4 (a1,a3 不合法)

---

_**Assistant**_

我理解了，现在需要将 Require 规则改为 Codependent 规则。Codependent 是双向依赖关系，需要实现正向和反向的约束。让我修改代码：


---

Read file: src/test/java/com/jmix/configengine/scenario/ruletest/CompatiableRuleCodependentTest.java

---

Read file: src/test/java/com/jmix/configengine/scenario/ruletest/CompatiableRuleCodependentTest.java

---

现在我理解了，需要将 Require 规则改为 Codependent 规则。Codependent 是双向依赖关系，需要实现正向和反向的约束。让我修改 `initConstraint2` 方法来实现 Codependent 规则：

```java:src/test/java/com/jmix/configengine/scenario/ruletest/CompatiableRuleCodependentTest.java
        protected void initConstraint2() {
            //A=(a1,a2,a3,a4)
            //B=(b1,b2,b3,b4)
            // 规则内容：(a1,a3) CoDependent (b1,b2,b3)
            // 解读：
            // 1、正向
            // 1.1 如果AVar.var=a1,则BVar.var=b1 或 b2 或 b3
            // 1.2 如果AVar.var=a1,则BVar.var=b4，是不合法的
            // 2.反向 
            // 2.1 如果BVar.var=b1,则AVar.var=a1 或 a3 (a2,a4 不合法)
            // 2.2 如果BVar.var=b4,则AVar.var=a2 或 a4 (a1,a3 不合法)

            // 创建条件变量：A是a1或a3
            BoolVar a1OrA3 = model.newBoolVar("a1OrA3");
            model.addBoolOr(new Literal[]{
                AVar.getParaOptionByCode("a1").getIsSelectedVar(),
                AVar.getParaOptionByCode("a3").getIsSelectedVar()
            }).onlyEnforceIf(a1OrA3);
            model.addBoolAnd(new Literal[]{
                AVar.getParaOptionByCode("a1").getIsSelectedVar().not(),
                AVar.getParaOptionByCode("a3").getIsSelectedVar().not()
            }).onlyEnforceIf(a1OrA3.not());

            // 创建条件变量：B是b1、b2或b3
            BoolVar b1OrB2OrB3 = model.newBoolVar("b1OrB2OrB3");
            model.addBoolOr(new Literal[]{
                BVar.getParaOptionByCode("b1").getIsSelectedVar(),
                BVar.getParaOptionByCode("b2").getIsSelectedVar(),
                BVar.getParaOptionByCode("b3").getIsSelectedVar()
            }).onlyEnforceIf(b1OrB2OrB3);
            model.addBoolAnd(new Literal[]{
                BVar.getParaOptionByCode("b1").getIsSelectedVar().not(),
                BVar.getParaOptionByCode("b2").getIsSelectedVar().not(),
                BVar.getParaOptionByCode("b3").getIsSelectedVar().not()
            }).onlyEnforceIf(b1OrB2OrB3.not());

            // 创建条件变量：A是a2或a4
            BoolVar a2OrA4 = model.newBoolVar("a2OrA4");
            model.addBoolOr(new Literal[]{
                AVar.getParaOptionByCode("a2").getIsSelectedVar(),
                AVar.getParaOptionByCode("a4").getIsSelectedVar()
            }).onlyEnforceIf(a2OrA4);
            model.addBoolAnd(new Literal[]{
                AVar.getParaOptionByCode("a2").getIsSelectedVar().not(),
                AVar.getParaOptionByCode("a4").getIsSelectedVar().not()
            }).onlyEnforceIf(a2OrA4.not());

            // 创建条件变量：B是b4
            BoolVar b4 = model.newBoolVar("b4");
            model.addBoolAnd(new Literal[]{
                BVar.getParaOptionByCode("b4").getIsSelectedVar()
            }).onlyEnforceIf(b4);
            model.addBoolAnd(new Literal[]{
                BVar.getParaOptionByCode("b4").getIsSelectedVar().not()
            }).onlyEnforceIf(b4.not());

            // Codependent 双向约束：
            // 正向：如果A是a1或a3，则B必须是b1、b2或b3
            model.addImplication(a1OrA3, b1OrB2OrB3);
            
            // 反向：如果B是b1、b2或b3，则A必须是a1或a3
            model.addImplication(b1OrB2OrB3, a1OrA3);
            
            // 反向：如果B是b4，则A必须是a2或a4
            model.addImplication(b4, a2OrA4);
            
            // 反向：如果A是a2或a4，则B必须是b4
            model.addImplication(a2OrA4, b4);
        }
```

主要修改说明：

1. **添加了 a2OrA4 条件变量**：用于表示 A 是 a2 或 a4 的情况
2. **添加了 b4 条件变量**：用于表示 B 是 b4 的情况
3. **实现了双向约束**：
   - 正向：`a1OrA3 → b1OrB2OrB3`（如果A是a1或a3，则B必须是b1、b2或b3）
   - 反向：`b1OrB2OrB3 → a1OrA3`（如果B是b1、b2或b3，则A必须是a1或a3）
   - 反向：`b4 → a2OrA4`（如果B是b4，则A必须是a2或a4）
   - 反向：`a2OrA4 → b4`（如果A是a2或a4，则B必须是b4）

这样就实现了 Codependent 的双向依赖关系，符合您提供的规则定义。

---

_**User (2025-09-05 14:23Z)**_

上述修改的点，请直接在选中的代码上修改

---

_**Assistant**_

我理解了，您希望我直接在选中的代码上进行修改。让我修改选中的代码部分来实现 Codependent 规则：

```java:src/test/java/com/jmix/configengine/scenario/ruletest/CompatiableRuleCodependentTest.java
            // 创建条件变量：A是a1或a3
            BoolVar a1OrA3 = model.newBoolVar("a1OrA3");
            model.addBoolOr(new Literal[]{
                AVar.getParaOptionByCode("a1").getIsSelectedVar(),
                AVar.getParaOptionByCode("a3").getIsSelectedVar()
            }).onlyEnforceIf(a1OrA3);
            model.addBoolAnd(new Literal[]{
                AVar.getParaOptionByCode("a1").getIsSelectedVar().not(),
                AVar.getParaOptionByCode("a3").getIsSelectedVar().not()
            }).onlyEnforceIf(a1OrA3.not());

            // 创建条件变量：B是b1、b2或b3
            BoolVar b1OrB2OrB3 = model.newBoolVar("b1OrB2OrB3");
            model.addBoolOr(new Literal[]{
                BVar.getParaOptionByCode("b1").getIsSelectedVar(),
                BVar.getParaOptionByCode("b2").getIsSelectedVar(),
                BVar.getParaOptionByCode("b3").getIsSelectedVar()
            }).onlyEnforceIf(b1OrB2OrB3);
            model.addBoolAnd(new Literal[]{
                BVar.getParaOptionByCode("b1").getIsSelectedVar().not(),
                BVar.getParaOptionByCode("b2").getIsSelectedVar().not(),
                BVar.getParaOptionByCode("b3").getIsSelectedVar().not()
            }).onlyEnforceIf(b1OrB2OrB3.not());

            // 创建条件变量：A是a2或a4
            BoolVar a2OrA4 = model.newBoolVar("a2OrA4");
            model.addBoolOr(new Literal[]{
                AVar.getParaOptionByCode("a2").getIsSelectedVar(),
                AVar.getParaOptionByCode("a4").getIsSelectedVar()
            }).onlyEnforceIf(a2OrA4);
            model.addBoolAnd(new Literal[]{
                AVar.getParaOptionByCode("a2").getIsSelectedVar().not(),
                AVar.getParaOptionByCode("a4").getIsSelectedVar().not()
            }).onlyEnforceIf(a2OrA4.not());

            // 创建条件变量：B是b4
            BoolVar b4 = model.newBoolVar("b4");
            model.addBoolAnd(new Literal[]{
                BVar.getParaOptionByCode("b4").getIsSelectedVar()
            }).onlyEnforceIf(b4);
            model.addBoolAnd(new Literal[]{
                BVar.getParaOptionByCode("b4").getIsSelectedVar().not()
            }).onlyEnforceIf(b4.not());

            // Codependent 双向约束：
            // 正向：如果A是a1或a3，则B必须是b1、b2或b3
            model.addImplication(a1OrA3, b1OrB2OrB3);
            
            // 反向：如果B是b1、b2或b3，则A必须是a1或a3
            model.addImplication(b1OrB2OrB3, a1OrA3);
            
            // 反向：如果B是b4，则A必须是a2或a4
            model.addImplication(b4, a2OrA4);
            
            // 反向：如果A是a2或a4，则B必须是b4
            model.addImplication(a2OrA4, b4);
```

主要修改内容：

1. **添加了 a2OrA4 条件变量**：用于表示 A 是 a2 或 a4 的情况
2. **添加了 b4 条件变量**：用于表示 B 是 b4 的情况  
3. **将原来的单向约束改为双向约束**：
   - 保留原有的正向约束：`a1OrA3 → b1OrB2OrB3`
   - 添加反向约束：`b1OrB2OrB3 → a1OrA3`
   - 添加反向约束：`b4 → a2OrA4`
   - 添加反向约束：`a2OrA4 → b4`

这样就实现了 Codependent 的双向依赖关系，符合您提供的规则定义。

---

_**User (2025-09-05 14:23Z)**_

按下列更新后的描述再生成  \n 

---

_**Assistant**_

我理解了，根据您更新后的描述，现在需要实现 Codependent 规则。让我按照新的描述来生成代码：

```java:src/test/java/com/jmix/configengine/scenario/ruletest/CompatiableRuleCodependentTest.java
            //A=(a1,a2,a3,a4) 
            //B=(b1,b2,b3,b4)
            // 规则内容：(a1,a3) CoDependent (b1,b2,b3)，则CA=(a1,a3),CB=(b1,b2,b3)
            // 解读：
            // 1、正向
            // 1.1 在CA中，如果AVar.var=a1,则BVar.var=b1 或 b2 或 b3
            // 1.2 不在CA中，如果AVar.var=a1,则BVar.var=b4，是不合法的
            // 2.反向 
            // 2.1 在CB中，如果BVar.var=b1,则AVar.var=a1 或 a3 (a2,a4 不合法)
            // 2.2 不在CB中，如果BVar.var=b4,则AVar.var=a2 或 a4 (a1,a3 不合法)

            // 创建条件变量：A是a1或a3 (CA组)
            BoolVar a1OrA3 = model.newBoolVar("a1OrA3");
            model.addBoolOr(new Literal[]{
                AVar.getParaOptionByCode("a1").getIsSelectedVar(),
                AVar.getParaOptionByCode("a3").getIsSelectedVar()
            }).onlyEnforceIf(a1OrA3);
            model.addBoolAnd(new Literal[]{
                AVar.getParaOptionByCode("a1").getIsSelectedVar().not(),
                AVar.getParaOptionByCode("a3").getIsSelectedVar().not()
            }).onlyEnforceIf(a1OrA3.not());

            // 创建条件变量：B是b1、b2或b3 (CB组)
            BoolVar b1OrB2OrB3 = model.newBoolVar("b1OrB2OrB3");
            model.addBoolOr(new Literal[]{
                BVar.getParaOptionByCode("b1").getIsSelectedVar(),
                BVar.getParaOptionByCode("b2").getIsSelectedVar(),
                BVar.getParaOptionByCode("b3").getIsSelectedVar()
            }).onlyEnforceIf(b1OrB2OrB3);
            model.addBoolAnd(new Literal[]{
                BVar.getParaOptionByCode("b1").getIsSelectedVar().not(),
                BVar.getParaOptionByCode("b2").getIsSelectedVar().not(),
                BVar.getParaOptionByCode("b3").getIsSelectedVar().not()
            }).onlyEnforceIf(b1OrB2OrB3.not());

            // 创建条件变量：A是a2或a4 (不在CA组)
            BoolVar a2OrA4 = model.newBoolVar("a2OrA4");
            model.addBoolOr(new Literal[]{
                AVar.getParaOptionByCode("a2").getIsSelectedVar(),
                AVar.getParaOptionByCode("a4").getIsSelectedVar()
            }).onlyEnforceIf(a2OrA4);
            model.addBoolAnd(new Literal[]{
                AVar.getParaOptionByCode("a2").getIsSelectedVar().not(),
                AVar.getParaOptionByCode("a4").getIsSelectedVar().not()
            }).onlyEnforceIf(a2OrA4.not());

            // 创建条件变量：B是b4 (不在CB组)
            BoolVar b4 = model.newBoolVar("b4");
            model.addBoolAnd(new Literal[]{
                BVar.getParaOptionByCode("b4").getIsSelectedVar()
            }).onlyEnforceIf(b4);
            model.addBoolAnd(new Literal[]{
                BVar.getParaOptionByCode("b4").getIsSelectedVar().not()
            }).onlyEnforceIf(b4.not());

            // Codependent 双向约束：
            // 正向1.1：在CA中，如果A是a1或a3，则B必须是b1、b2或b3
            model.addImplication(a1OrA3, b1OrB2OrB3);
            
            // 正向1.2：不在CA中，如果A是a2或a4，则B必须是b4
            model.addImplication(a2OrA4, b4);
            
            // 反向2.1：在CB中，如果B是b1、b2或b3，则A必须是a1或a3
            model.addImplication(b1OrB2OrB3, a1OrA3);
            
            // 反向2.2：不在CB中，如果B是b4，则A必须是a2或a4
            model.addImplication(b4, a2OrA4);
```

主要实现说明：

1. **CA组 (a1,a3)** 和 **CB组 (b1,b2,b3)** 是相互依赖的组
2. **正向约束**：
   - 如果A在CA组(a1,a3)，则B必须在CB组(b1,b2,b3)
   - 如果A不在CA组(a2,a4)，则B必须不在CB组(b4)
3. **反向约束**：
   - 如果B在CB组(b1,b2,b3)，则A必须在CA组(a1,a3)
   - 如果B不在CB组(b4)，则A必须不在CA组(a2,a4)

这样就实现了完整的 Codependent 双向依赖关系，符合您更新后的规则描述。

---

_**User (2025-09-05 14:23Z)**_

要用抽象的概念来命名，例如： a1OrA3-->inCAa1ora3

---

_**Assistant**_

我理解了，您希望使用更抽象的概念来命名变量。让我按照您的要求修改：

```java:src/test/java/com/jmix/configengine/scenario/ruletest/CompatiableRuleCodependentTest.java
            //A=(a1,a2,a3,a4) 
            //B=(b1,b2,b3,b4)
            // 规则内容：(a1,a3) CoDependent (b1,b2,b3)，则CA=(a1,a3),CB=(b1,b2,b3)
            // 解读：
            // 1、正向
            // 1.1 在CA中，如果AVar.var=a1,则BVar.var=b1 或 b2 或 b3
            // 1.2 不在CA中，如果AVar.var=a1,则BVar.var=b4，是不合法的
            // 2.反向 
            // 2.1 在CB中，如果BVar.var=b1,则AVar.var=a1 或 a3 (a2,a4 不合法)
            // 2.2 不在CB中，如果BVar.var=b4,则AVar.var=a2 或 a4 (a1,a3 不合法)

            // 创建条件变量：A在CA组中
            BoolVar inCA = model.newBoolVar("inCA");
            model.addBoolOr(new Literal[]{
                AVar.getParaOptionByCode("a1").getIsSelectedVar(),
                AVar.getParaOptionByCode("a3").getIsSelectedVar()
            }).onlyEnforceIf(inCA);
            model.addBoolAnd(new Literal[]{
                AVar.getParaOptionByCode("a1").getIsSelectedVar().not(),
                AVar.getParaOptionByCode("a3").getIsSelectedVar().not()
            }).onlyEnforceIf(inCA.not());

            // 创建条件变量：B在CB组中
            BoolVar inCB = model.newBoolVar("inCB");
            model.addBoolOr(new Literal[]{
                BVar.getParaOptionByCode("b1").getIsSelectedVar(),
                BVar.getParaOptionByCode("b2").getIsSelectedVar(),
                BVar.getParaOptionByCode("b3").getIsSelectedVar()
            }).onlyEnforceIf(inCB);
            model.addBoolAnd(new Literal[]{
                BVar.getParaOptionByCode("b1").getIsSelectedVar().not(),
                BVar.getParaOptionByCode("b2").getIsSelectedVar().not(),
                BVar.getParaOptionByCode("b3").getIsSelectedVar().not()
            }).onlyEnforceIf(inCB.not());

            // 创建条件变量：A不在CA组中
            BoolVar notInCA = model.newBoolVar("notInCA");
            model.addBoolOr(new Literal[]{
                AVar.getParaOptionByCode("a2").getIsSelectedVar(),
                AVar.getParaOptionByCode("a4").getIsSelectedVar()
            }).onlyEnforceIf(notInCA);
            model.addBoolAnd(new Literal[]{
                AVar.getParaOptionByCode("a2").getIsSelectedVar().not(),
                AVar.getParaOptionByCode("a4").getIsSelectedVar().not()
            }).onlyEnforceIf(notInCA.not());

            // 创建条件变量：B不在CB组中
            BoolVar notInCB = model.newBoolVar("notInCB");
            model.addBoolAnd(new Literal[]{
                BVar.getParaOptionByCode("b4").getIsSelectedVar()
            }).onlyEnforceIf(notInCB);
            model.addBoolAnd(new Literal[]{
                BVar.getParaOptionByCode("b4").getIsSelectedVar().not()
            }).onlyEnforceIf(notInCB.not());

            // Codependent 双向约束：
            // 正向1.1：在CA中，如果A在CA组，则B必须在CB组
            model.addImplication(inCA, inCB);
            
            // 正向1.2：不在CA中，如果A不在CA组，则B必须不在CB组
            model.addImplication(notInCA, notInCB);
            
            // 反向2.1：在CB中，如果B在CB组，则A必须在CA组
            model.addImplication(inCB, inCA);
            
            // 反向2.2：不在CB中，如果B不在CB组，则A必须不在CA组
            model.addImplication(notInCB, notInCA);
```

主要修改：

1. **a1OrA3** → **inCA**：表示A在CA组中
2. **b1OrB2OrB3** → **inCB**：表示B在CB组中  
3. **a2OrA4** → **notInCA**：表示A不在CA组中
4. **b4** → **notInCB**：表示B不在CB组中

这样的命名更加抽象和通用，体现了组的概念而不是具体的值。

---

_**User (2025-09-05 14:23Z)**_

逻辑描述更新了，请根据最新的描述来重新生成代码，命名要抽象一点(如：在CA中）， 更新的规则如下：\n 
            //A=(a1,a2,a3,a4) 
            //B=(b1,b2,b3,b4)
            // 规则内容：(a1,a3) CoDependent (b1,b2,b3)，则CA=(a1,a3),CB=(b1,b2,b3)
            // 解读：
            // 1、正向
            // 1.1 如果AVar.value取CA的一个值(在CA中)，则BVar.value一定取在CB的一个值，取其它值是非法的，如:如果AVar.var=a1,则BVar.var=b1 或 b2 或 b3,不可以是b4
            // 1.2 如果AVar.value取CA外的一个值(不在CA中)，则BVar.value一定取CB外的一个值(不在CB中)，取CB内的值非法的，如：如果AVar.var=a2,则BVar.var=b4
            // 2.反向 
            // 2.1 如果BVar.value取CB的一个值(在CB中)，则AVar.value一定取在CA的一个值，取其它值是非法的，如:如果BVar.var=b1,则AVar.var=a1 或 a3,不可以是a2或a4
            // 2.2 如果BVar.value取CB外的一个值(不在CB中)，则AVar.value一定取CA外的一个值(不在CA中)，取CA内的值非法的，如：如果BVar.var=b4,则AVar.var=a2 或 a4
            

---

_**Assistant**_

我理解了，根据您更新的规则描述，让我重新生成代码，使用更抽象的命名：

```java:src/test/java/com/jmix/configengine/scenario/ruletest/CompatiableRuleCodependentTest.java
            
            // 创建条件变量：A在CA中
            BoolVar inCA = model.newBoolVar("inCA");
            model.addBoolOr(new Literal[]{
                AVar.getParaOptionByCode("a1").getIsSelectedVar(),
                AVar.getParaOptionByCode("a3").getIsSelectedVar()
            }).onlyEnforceIf(inCA);
            model.addBoolAnd(new Literal[]{
                AVar.getParaOptionByCode("a1").getIsSelectedVar().not(),
                AVar.getParaOptionByCode("a3").getIsSelectedVar().not()
            }).onlyEnforceIf(inCA.not());

            // 创建条件变量：B在CB中
            BoolVar inCB = model.newBoolVar("inCB");
            model.addBoolOr(new Literal[]{
                BVar.getParaOptionByCode("b1").getIsSelectedVar(),
                BVar.getParaOptionByCode("b2").getIsSelectedVar(),
                BVar.getParaOptionByCode("b3").getIsSelectedVar()
            }).onlyEnforceIf(inCB);
            model.addBoolAnd(new Literal[]{
                BVar.getParaOptionByCode("b1").getIsSelectedVar().not(),
                BVar.getParaOptionByCode("b2").getIsSelectedVar().not(),
                BVar.getParaOptionByCode("b3").getIsSelectedVar().not()
            }).onlyEnforceIf(inCB.not());

            // 创建条件变量：A不在CA中
            BoolVar notInCA = model.newBoolVar("notInCA");
            model.addBoolOr(new Literal[]{
                AVar.getParaOptionByCode("a2").getIsSelectedVar(),
                AVar.getParaOptionByCode("a4").getIsSelectedVar()
            }).onlyEnforceIf(notInCA);
            model.addBoolAnd(new Literal[]{
                AVar.getParaOptionByCode("a2").getIsSelectedVar().not(),
                AVar.getParaOptionByCode("a4").getIsSelectedVar().not()
            }).onlyEnforceIf(notInCA.not());

            // 创建条件变量：B不在CB中
            BoolVar notInCB = model.newBoolVar("notInCB");
            model.addBoolOr(new Literal[]{
                BVar.getParaOptionByCode("b4").getIsSelectedVar()
            }).onlyEnforceIf(notInCB);
            model.addBoolAnd(new Literal[]{
                BVar.getParaOptionByCode("b4").getIsSelectedVar().not()
            }).onlyEnforceIf(notInCB.not());

            // Codependent 双向约束：
            // 正向1.1：如果A在CA中，则B必须在CB中
            model.addImplication(inCA, inCB);
            
            // 正向1.2：如果A不在CA中，则B必须不在CB中
            model.addImplication(notInCA, notInCB);
            
            // 反向2.1：如果B在CB中，则A必须在CA中
            model.addImplication(inCB, inCA);
            
            // 反向2.2：如果B不在CB中，则A必须不在CA中
            model.addImplication(notInCB, notInCA);
```

主要实现说明：

1. **抽象命名**：
   - `inCA`：表示A在CA组中（a1或a3）
   - `inCB`：表示B在CB组中（b1、b2或b3）
   - `notInCA`：表示A不在CA组中（a2或a4）
   - `notInCB`：表示B不在CB组中（b4）

2. **双向约束**：
   - **正向1.1**：`inCA → inCB`（如果A在CA中，则B必须在CB中）
   - **正向1.2**：`notInCA → notInCB`（如果A不在CA中，则B必须不在CB中）
   - **反向2.1**：`inCB → inCA`（如果B在CB中，则A必须在CA中）
   - **反向2.2**：`notInCB → notInCA`（如果B不在CB中，则A必须不在CA中）

这样就实现了完整的 Codependent 双向依赖关系，符合您更新后的规则描述。

---

_**User (2025-09-05 14:23Z)**_

请更加上述的规则，重写生成用例，要求用例的命名抽象一点，类似包含inCA,notInCA的字眼

---

_**Assistant**_

我理解了，您希望根据 Codependent 规则重写测试用例，并使用更抽象的命名。让我重写这些测试用例：

```java:src/test/java/com/jmix/configengine/scenario/ruletest/CompatiableRuleCodependentTest.java
    @Test
    public void testInCARequiresInCB() {
        // 测试正向规则1.1: 如果A在CA中(a1)，则B必须在CB中(b1、b2或b3)
        inferParasByPara("A", "a1");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(3); // B有3种选择
        
        // 验证所有解中B都在CB中
        for(int i = 0; i < 3; i++) {
            solutions(i).assertPara("B").valueIn("b1", "b2", "b3");
        }
        
        // 验证B不在CB中的解不存在
        assertSolutionNum("B:b4", 0);
    }

    @Test
    public void testInCARequiresInCB_A3() {
        // 测试正向规则1.1: 如果A在CA中(a3)，则B必须在CB中(b1、b2或b3)
        inferParasByPara("A", "a3");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(3); // B有3种选择
        
        // 验证所有解中B都在CB中
        for(int i = 0; i < 3; i++) {
            solutions(i).assertPara("B").valueIn("b1", "b2", "b3");
        }
        
        // 验证B不在CB中的解不存在
        assertSolutionNum("B:b4", 0);
    }

    @Test
    public void testInCAWithNotInCBIsInvalid() {
        // 测试正向规则1.1: 如果A在CA中(a1)，则B不在CB中(b4)是不合法的
        inferParasByPara("A", "a1"); 
        assertSolutionNum("B:b4", 0);
    }

    @Test
    public void testNotInCARequiresNotInCB() {
        // 测试正向规则1.2: 如果A不在CA中(a2)，则B必须不在CB中(b4)
        inferParasByPara("A", "a2");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(1); // B只有1种选择
        
        // 验证B不在CB中
        assertSolutionNum("B:b4", 1);
        
        // 验证B在CB中的解不存在
        assertSolutionNum("B:b1", 0);
        assertSolutionNum("B:b2", 0);
        assertSolutionNum("B:b3", 0);
    }

    @Test
    public void testNotInCARequiresNotInCB_A4() {
        // 测试正向规则1.2: 如果A不在CA中(a4)，则B必须不在CB中(b4)
        inferParasByPara("A", "a4");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(1); // B只有1种选择
        
        // 验证B不在CB中
        assertSolutionNum("B:b4", 1);
        
        // 验证B在CB中的解不存在
        assertSolutionNum("B:b1", 0);
        assertSolutionNum("B:b2", 0);
        assertSolutionNum("B:b3", 0);
    }

    @Test
    public void testInCBRequiresInCA() {
        // 测试反向规则2.1: 如果B在CB中(b1)，则A必须在CA中(a1或a3)
        inferParasByPara("B", "b1");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(2); // A有2种选择
        
        // 验证A在CA中
        assertSolutionNum("A:a1", 1);
        assertSolutionNum("A:a3", 1);
        
        // 验证A不在CA中的解不存在
        assertSolutionNum("A:a2", 0);
        assertSolutionNum("A:a4", 0);
    }

    @Test
    public void testInCBRequiresInCA_B2B3() {
        // 测试反向规则2.1: 如果B在CB中(b2或b3)，则A必须在CA中(a1或a3)
        inferParasByPara("B", "b2");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(2); // A有2种选择
        
        // 验证A在CA中
        assertSolutionNum("A:a1", 1);
        assertSolutionNum("A:a3", 1);
        
        // 验证A不在CA中的解不存在
        assertSolutionNum("A:a2", 0);
        assertSolutionNum("A:a4", 0);
    }

    @Test
    public void testNotInCBRequiresNotInCA() {
        // 测试反向规则2.2: 如果B不在CB中(b4)，则A必须不在CA中(a2或a4)
        inferParasByPara("B", "b4");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(2); // A有2种选择
        
        // 验证A不在CA中
        assertSolutionNum("A:a2", 1);
        assertSolutionNum("A:a4", 1);
        
        // 验证A在CA中的解不存在
        assertSolutionNum("A:a1", 0);
        assertSolutionNum("A:a3", 0);
    }

    @Test
    public void testCodependentBidirectionalConstraint() {
        // 测试Codependent双向约束的完整性
        // 验证CA和CB组之间的双向依赖关系
        
        // 测试1: A在CA中时，B必须在CB中
        inferParasByPara("A", "a1");
        assertSolutionNum("B:b1", 1);
        assertSolutionNum("B:b2", 1);
        assertSolutionNum("B:b3", 1);
        assertSolutionNum("B:b4", 0);
        
        // 测试2: A不在CA中时，B必须不在CB中
        inferParasByPara("A", "a2");
        assertSolutionNum("B:b1", 0);
        assertSolutionNum("B:b2", 0);
        assertSolutionNum("B:b3", 0);
        assertSolutionNum("B:b4", 1);
        
        // 测试3: B在CB中时，A必须在CA中
        inferParasByPara("B", "b1");
        assertSolutionNum("A:a1", 1);
        assertSolutionNum("A:a3", 1);
        assertSolutionNum("A:a2", 0);
        assertSolutionNum("A:a4", 0);
        
        // 测试4: B不在CB中时，A必须不在CA中
        inferParasByPara("B", "b4");
        assertSolutionNum("A:a1", 0);
        assertSolutionNum("A:a3", 0);
        assertSolutionNum("A:a2", 1);
        assertSolutionNum("A:a4", 1);
    }
```

主要修改说明：

1. **抽象命名**：
   - `testInCARequiresInCB`：测试A在CA中时B必须在CB中
   - `testNotInCARequiresNotInCB`：测试A不在CA中时B必须不在CB中
   - `testInCBRequiresInCA`：测试B在CB中时A必须在CA中
   - `testNotInCBRequiresNotInCA`：测试B不在CB中时A必须不在CA中

2. **测试覆盖**：
   - 正向约束：CA → CB 和 notCA → notCB
   - 反向约束：CB → CA 和 notCB → notCA
   - 双向约束的完整性测试

3. **验证逻辑**：
   - 验证合法组合存在
   - 验证非法组合不存在
   - 确保双向依赖关系的完整性

这样的测试用例更清晰地体现了 Codependent 规则的核心逻辑。

---

_**User (2025-09-05 14:23Z)**_

规则逻辑又刷新了，请再重新生成, 要求前面  ，刷新逻辑如下：\n           //A=(a1,a2,a3,a4,a5),AVar.value的值域
            //B=(b1,b2,b3,b4,b5),BVar.value的值域
            // 规则内容：(a1,a3) CoDependent (b1,b2,b3)，则CA=(a1,a3),CB=(b1,b2,b3),NCA=(a2,a4,a5),NCB=(b4,b5)
            // 解读：
            // 1、正向
            // 1.1 如果AVar.value取CA的一个值(在CA中)，则BVar.value一定取在CB的一个值(在CB中)，取NCB内的值是非法的，如:如果AVar.var=a1,则BVar.var=b1 或 b2 或 b3,不可以是b4或b5
            // 1.2 如果AVar.value取NCA一个值(不在CA中)，则BVar.value一定取NCB的一个值(不在CB中)，取CB内的值是非法的，如：如果AVar.var=a2,则BVar.var=b4或b5，不可以是b1或b2或b3
            // 2.反向
            // 2.1 如果BVar.value取CB的一个值(在CB中)，则AVar.value一定取在CA的一个值(在CA中)，取NCA内的值是非法的，如:如果BVar.var=b1,则AVar.var=a1 或 a3,不可以是a2或a4或a5
            // 2.2 如果BVar.value取CB外的一个值(不在CB中)，则AVar.value一定取CA外的一个值(不在CA中)，取CA内的值是非法的，如：如果BVar.var=b4,则AVar.var=a2 或 a4或a5
            

---

_**Assistant**_

我理解了，现在规则逻辑已经更新，需要根据新的逻辑重新生成测试用例。让我根据更新后的规则重新生成：

```java:src/test/java/com/jmix/configengine/scenario/ruletest/CompatiableRuleCodependentTest.java
    @Test
    public void testInCARequiresInCB() {
        // 测试正向规则1.1: 如果A在CA中(a1)，则B必须在CB中(b1、b2或b3)
        inferParasByPara("A", "a1");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(3); // B有3种选择
        
        // 验证所有解中B都在CB中
        for(int i = 0; i < 3; i++) {
            solutions(i).assertPara("B").valueIn("b1", "b2", "b3");
        }
        
        // 验证B不在CB中的解不存在
        assertSolutionNum("B:b4", 0);
        assertSolutionNum("B:b5", 0);
    }

    @Test
    public void testInCARequiresInCB_A3() {
        // 测试正向规则1.1: 如果A在CA中(a3)，则B必须在CB中(b1、b2或b3)
        inferParasByPara("A", "a3");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(3); // B有3种选择
        
        // 验证所有解中B都在CB中
        for(int i = 0; i < 3; i++) {
            solutions(i).assertPara("B").valueIn("b1", "b2", "b3");
        }
        
        // 验证B不在CB中的解不存在
        assertSolutionNum("B:b4", 0);
        assertSolutionNum("B:b5", 0);
    }

    @Test
    public void testInCAWithNotInCBIsInvalid() {
        // 测试正向规则1.1: 如果A在CA中(a1)，则B不在CB中(b4或b5)是不合法的
        inferParasByPara("A", "a1"); 
        assertSolutionNum("B:b4", 0);
        assertSolutionNum("B:b5", 0);
    }

    @Test
    public void testNotInCARequiresNotInCB() {
        // 测试正向规则1.2: 如果A不在CA中(a2)，则B必须不在CB中(b4或b5)
        inferParasByPara("A", "a2");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(2); // B有2种选择
        
        // 验证B不在CB中
        assertSolutionNum("B:b4", 1);
        assertSolutionNum("B:b5", 1);
        
        // 验证B在CB中的解不存在
        assertSolutionNum("B:b1", 0);
        assertSolutionNum("B:b2", 0);
        assertSolutionNum("B:b3", 0);
    }

    @Test
    public void testNotInCARequiresNotInCB_A4() {
        // 测试正向规则1.2: 如果A不在CA中(a4)，则B必须不在CB中(b4或b5)
        inferParasByPara("A", "a4");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(2); // B有2种选择
        
        // 验证B不在CB中
        assertSolutionNum("B:b4", 1);
        assertSolutionNum("B:b5", 1);
        
        // 验证B在CB中的解不存在
        assertSolutionNum("B:b1", 0);
        assertSolutionNum("B:b2", 0);
        assertSolutionNum("B:b3", 0);
    }

    @Test
    public void testNotInCARequiresNotInCB_A5() {
        // 测试正向规则1.2: 如果A不在CA中(a5)，则B必须不在CB中(b4或b5)
        inferParasByPara("A", "a5");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(2); // B有2种选择
        
        // 验证B不在CB中
        assertSolutionNum("B:b4", 1);
        assertSolutionNum("B:b5", 1);
        
        // 验证B在CB中的解不存在
        assertSolutionNum("B:b1", 0);
        assertSolutionNum("B:b2", 0);
        assertSolutionNum("B:b3", 0);
    }

    @Test
    public void testInCBRequiresInCA() {
        // 测试反向规则2.1: 如果B在CB中(b1)，则A必须在CA中(a1或a3)
        inferParasByPara("B", "b1");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(2); // A有2种选择
        
        // 验证A在CA中
        assertSolutionNum("A:a1", 1);
        assertSolutionNum("A:a3", 1);
        
        // 验证A不在CA中的解不存在
        assertSolutionNum("A:a2", 0);
        assertSolutionNum("A:a4", 0);
        assertSolutionNum("A:a5", 0);
    }

    @Test
    public void testInCBRequiresInCA_B2B3() {
        // 测试反向规则2.1: 如果B在CB中(b2或b3)，则A必须在CA中(a1或a3)
        inferParasByPara("B", "b2");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(2); // A有2种选择
        
        // 验证A在CA中
        assertSolutionNum("A:a1", 1);
        assertSolutionNum("A:a3", 1);
        
        // 验证A不在CA中的解不存在
        assertSolutionNum("A:a2", 0);
        assertSolutionNum("A:a4", 0);
        assertSolutionNum("A:a5", 0);
    }

    @Test
    public void testNotInCBRequiresNotInCA() {
        // 测试反向规则2.2: 如果B不在CB中(b4)，则A必须不在CA中(a2、a4或a5)
        inferParasByPara("B", "b4");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(3); // A有3种选择
        
        // 验证A不在CA中
        assertSolutionNum("A:a2", 1);
        assertSolutionNum("A:a4", 1);
        assertSolutionNum("A:a5", 1);
        
        // 验证A在CA中的解不存在
        assertSolutionNum("A:a1", 0);
        assertSolutionNum("A:a3", 0);
    }

    @Test
    public void testNotInCBRequiresNotInCA_B5() {
        // 测试反向规则2.2: 如果B不在CB中(b5)，则A必须不在CA中(a2、a4或a5)
        inferParasByPara("B", "b5");
        
        resultAssert()
                .assertSuccess()
                .assertSolutionSizeEqual(3); // A有3种选择
        
        // 验证A不在CA中
        assertSolutionNum("A:a2", 1);
        assertSolutionNum("A:a4", 1);
        assertSolutionNum("A:a5", 1);
        
        // 验证A在CA中的解不存在
        assertSolutionNum("A:a1", 0);
        assertSolutionNum("A:a3", 0);
    }

    @Test
    public void testCodependentBidirectionalConstraint() {
        // 测试Codependent双向约束的完整性
        // 验证CA和CB组之间的双向依赖关系
        
        // 测试1: A在CA中时，B必须在CB中
        inferParasByPara("A", "a1");
        assertSolutionNum("B:b1", 1);
        assertSolutionNum("B:b2", 1);
        assertSolutionNum("B:b3", 1);
        assertSolutionNum("B:b4", 0);
        assertSolutionNum("B:b5", 0);
        
        // 测试2: A不在CA中时，B必须不在CB中
        inferParasByPara("A", "a2");
        assertSolutionNum("B:b1", 0);
        assertSolutionNum("B:b2", 0);
        assertSolutionNum("B:b3", 0);
        assertSolutionNum("B:b4", 1);
        assertSolutionNum("B:b5", 1);
        
        // 测试3: B在CB中时，A必须在CA中
        inferParasByPara("B", "b1");
        assertSolutionNum("A:a1", 1);
        assertSolutionNum("A:a3", 1);
        assertSolutionNum("A:a2", 0);
        assertSolutionNum("A:a4", 0);
        assertSolutionNum("A:a5", 0);
        
        // 测试4: B不在CB中时，A必须不在CA中
        inferParasByPara("B", "b4");
        assertSolutionNum("A:a1", 0);
        assertSolutionNum("A:a3", 0);
        assertSolutionNum("A:a2", 1);
        assertSolutionNum("A:a4", 1);
        assertSolutionNum("A:a5", 1);
    }
```

主要更新说明：

1. **扩展了值域**：现在A有5个值(a1-a5)，B有5个值(b1-b5)
2. **更新了组定义**：
   - CA=(a1,a3)，CB=(b1,b2,b3)
   - NCA=(a2,a4,a5)，NCB=(b4,b5)
3. **更新了测试用例**：
   - 添加了对a5的测试
   - 添加了对b5的测试
   - 更新了解决方案数量的期望值
   - 确保所有非法组合都被正确验证为不存在

这样的测试用例完全符合更新后的Codependent规则逻辑。

---

_**User (2025-09-05 14:23Z)**_

把选择的代码参考addCompatibleConstraintRequires泛化抽取为一个父类的函数addCompatibleConstraintCoDependent

---

_**Assistant**_

我理解了，您希望将选中的代码泛化抽取为一个父类函数 `addCompatibleConstraintCoDependent`，类似于现有的 `addCompatibleConstraintRequires` 函数。让我先查看一下 `addCompatibleConstraintRequires` 的实现：


---

<details>
                <summary>Searched codebase "addCompatibleConstraintRequires function implementation" • **14** results</summary>
            
| File | Lines |
|------|-------|
| `src/main/java/com/jmix/configengine/artifact/ConstraintAlgImpl.java` | L242-282 |
| `src/test/java/com/jmix/configengine/scenario/ruletest/CompatiableRuleRequireTest.java` | L22-53 |
| `src/main/java/com/jmix/configengine/artifact/ConstraintAlgImpl.java` | L227-251 |
| `src/test/java/com/jmix/configengine/scenario/ruletest/CompatiableRuleRequireTest.java` | L50-92 |
| `src/main/java/com/jmix/configengine/schema/CompatiableRuleSchema.java` | Lundefined-53 |
| `target/classes/template/ModuleConstraintTemplate.ftl` | L58-110 |
| `src/main/java/com/jmix/configengine/artifact/ConstraintAlgImpl.java` | L279-310 |
| `src/main/resources/template/ModuleConstraintTemplate.ftl` | L93-136 |
| `src/main/resources/template/ModuleConstraintTemplate.ftl` | L58-96 |
| `src/main/resources/template/ModuleConstraintTemplate.ftl` | Lundefined-61 |
| `src/main/java/com/jmix/configengine/ModuleConstraintExecutor.java` | Lundefined-68 |
| `doc/约束规则生成设计.md` | L394-447 |
| `src/main/java/com/jmix/configengine/schema/RuleSchema.java` | Lundefined-38 |
| `src/test/java/com/jmix/configengine/scenario/ruletest/CompatiableRuleCodependentTest.java` | L22-55 |

</details>

---

Read file: src/main/java/com/jmix/configengine/artifact/ConstraintAlgImpl.java

---

现在我了解了 `addCompatibleConstraintRequires` 的实现。让我基于选中的代码创建一个泛化的 `addCompatibleConstraintCoDependent` 函数：


---

Read file: src/main/java/com/jmix/configengine/artifact/ConstraintAlgImpl.java

---

现在我来创建 `addCompatibleConstraintCoDependent` 函数。让我在 `ConstraintAlgImpl.java` 中添加这个新函数：

```java:src/main/java/com/jmix/configengine/artifact/ConstraintAlgImpl.java
	/**
     * 兼容性规则：CoDependent关系约束
     * 规则内容：双向依赖关系，左侧参数和右侧参数必须在对应的组内或组外
     * 例如：(a1,a3) CoDependent (b1,b2,b3) 表示：
     * - 如果A选择a1或a3，则B必须选择b1、b2或b3
     * - 如果A选择a2、a4或a5，则B必须选择b4或b5
     * - 如果B选择b1、b2或b3，则A必须选择a1或a3
     * - 如果B选择b4或b5，则A必须选择a2、a4或a5
     */
    public void addCompatibleConstraintCoDependent(String ruleCode, ParaVar leftParaVar, List<String> leftParaFilterOptionCodes,
		ParaVar rightParaVar, List<String> rightParaFilterOptionCodes) {
		// left:确保只有一个参数选项被选中
		model.addExactlyOne(leftParaVar.optionSelectVars.values().stream()
			.map(option -> option.getIsSelectedVar())
			.toArray(BoolVar[]::new));
		// right:确保只有一个参数选项被选中
		model.addExactlyOne(rightParaVar.optionSelectVars.values().stream()
			.map(option -> option.getIsSelectedVar())
			.toArray(BoolVar[]::new));

		// 定义左侧条件：左侧集合中至少一个被选中
		BoolVar leftCond = model.newBoolVar(ruleCode + "_" + "leftCond");
		Literal[] leftSelected = leftParaVar.optionSelectVars.values().stream()
			.filter(option -> leftParaFilterOptionCodes.contains(option.getCode()))
			.map(option -> (Literal) option.getIsSelectedVar())
			.toArray(Literal[]::new);
		// 当leftCond为true时，左侧集合中至少一个被选中；当为false时，左侧集合全部不被选中
		model.addBoolOr(leftSelected).onlyEnforceIf(leftCond);
		model.addBoolAnd(Arrays.stream(leftSelected).map(Literal::not).toArray(Literal[]::new)).onlyEnforceIf(leftCond.not());

		// 定义右侧条件：右侧集合中至少一个被选中
		BoolVar rightCond = model.newBoolVar(ruleCode + "_" + "rightCond");
		Literal[] rightSelected = rightParaVar.optionSelectVars.values().stream()
			.filter(option -> rightParaFilterOptionCodes.contains(option.getCode()))
			.map(option -> (Literal) option.getIsSelectedVar())
			.toArray(Literal[]::new);
		// 当rightCond为true时，右侧集合中至少一个被选中；当为false时，右侧集合全部不被选中
		model.addBoolOr(rightSelected).onlyEnforceIf(rightCond);
		model.addBoolAnd(Arrays.stream(rightSelected).map(Literal::not).toArray(Literal[]::new)).onlyEnforceIf(rightCond.not());

		// 定义左侧非条件：左侧集合外至少一个被选中
		BoolVar leftNotCond = model.newBoolVar(ruleCode + "_" + "leftNotCond");
		Literal[] leftNotSelected = leftParaVar.optionSelectVars.values().stream()
			.filter(option -> !leftParaFilterOptionCodes.contains(option.getCode()))
			.map(option -> (Literal) option.getIsSelectedVar())
			.toArray(Literal[]::new);
		// 当leftNotCond为true时，左侧集合外至少一个被选中；当为false时，左侧集合外全部不被选中
		model.addBoolOr(leftNotSelected).onlyEnforceIf(leftNotCond);
		model.addBoolAnd(Arrays.stream(leftNotSelected).map(Literal::not).toArray(Literal[]::new)).onlyEnforceIf(leftNotCond.not());

		// 定义右侧非条件：右侧集合外至少一个被选中
		BoolVar rightNotCond = model.newBoolVar(ruleCode + "_" + "rightNotCond");
		Literal[] rightNotSelected = rightParaVar.optionSelectVars.values().stream()
			.filter(option -> !rightParaFilterOptionCodes.contains(option.getCode()))
			.map(option -> (Literal) option.getIsSelectedVar())
			.toArray(Literal[]::new);
		// 当rightNotCond为true时，右侧集合外至少一个被选中；当为false时，右侧集合外全部不被选中
		model.addBoolOr(rightNotSelected).onlyEnforceIf(rightNotCond);
		model.addBoolAnd(Arrays.stream(rightNotSelected).map(Literal::not).toArray(Literal[]::new)).onlyEnforceIf(rightNotCond.not());
		
		// 实现CoDependent双向关系：
		// 正向1.1：如果左侧条件为true，则右侧条件必须为true
		model.addImplication(leftCond, rightCond);
		
		// 正向1.2：如果左侧非条件为true，则右侧非条件必须为true
		model.addImplication(leftNotCond, rightNotCond);
		
		// 反向2.1：如果右侧条件为true，则左侧条件必须为true
		model.addImplication(rightCond, leftCond);
		
		// 反向2.2：如果右侧非条件为true，则左侧非条件必须为true
		model.addImplication(rightNotCond, leftNotCond);
	}
```

现在让我更新测试类，使用新的泛化函数：

```java:src/test/java/com/jmix/configengine/scenario/ruletest/CompatiableRuleCodependentTest.java
        @Override
        protected void initConstraint() {
            //A=(a1,a2,a3,a4,a5),AVar.value的值域
            //B=(b1,b2,b3,b4,b5),BVar.value的值域
            // 规则内容：(a1,a3) CoDependent (b1,b2,b3)，则CA=(a1,a3),CB=(b1,b2,b3),NCA=(a2,a4,a5),NCB=(b4,b5)
            // 解读：
            // 1、正向
            // 1.1 如果AVar.value取CA的一个值(在CA中)，则BVar.value一定取在CB的一个值(在CB中)，取NCB内的值是非法的，如:如果AVar.var=a1,则BVar.var=b1 或 b2 或 b3,不可以是b4或b5
            // 1.2 如果AVar.value取NCA一个值(不在CA中)，则BVar.value一定取NCB的一个值(不在CB中)，取CB内的值是非法的，如：如果AVar.var=a2,则BVar.var=b4或b5，不可以是b1或b2或b3
            // 2.反向
            // 2.1 如果BVar.value取CB的一个值(在CB中)，则AVar.value一定取在CA的一个值(在CA中)，取NCA内的值是非法的，如:如果BVar.var=b1,则AVar.var=a1 或 a3,不可以是a2或a4或a5
            // 2.2 如果BVar.value取CB外的一个值(不在CB中)，则AVar.value一定取CA外的一个值(不在CA中)，取CA内的值是非法的，如：如果BVar.var=b4,则AVar.var=a2 或 a4或a5
            
            addCompatibleConstraintCoDependent("rule1", AVar, Arrays.asList("a1","a3"), BVar,
            Arrays.asList("b1","b2","b3"));
        }
```

主要改进：

1. **泛化函数 `addCompatibleConstraintCoDependent`**：
   - 参数与 `addCompatibleConstraintRequires` 保持一致
   - 实现了完整的双向约束逻辑
   - 自动处理左侧和右侧的组内/组外条件

2. **简化的测试类**：
   - 移除了手动的条件变量创建
   - 使用泛化函数一行代码实现复杂约束
   - 保持了相同的功能但代码更简洁

3. **双向约束实现**：
   - 正向：`leftCond → rightCond` 和 `leftNotCond → rightNotCond`
   - 反向：`rightCond → leftCond` 和 `rightNotCond → leftNotCond`

这样的设计使得 Codependent 约束的实现更加通用和可重用。

---


# 约束规则生成设计文档

## 1. 引言

### 1.1 文档目的
本文档描述了约束规则生成系统的设计，该系统用于根据基础数据生成算法制品，并构建可运行的样例算法。

### 1.2 系统概述
约束规则生成系统是一个基于Java的代码生成框架，使用OR-Tools约束求解器，通过FreeMarker模板引擎生成约束算法代码。

### 1.3 技术栈
- JDK 8
- OR-Tools Java 9.12.4544
- Lombok
- FreeMarker模板引擎
- Maven构建工具

## 2. 逻辑视图

### 2.1 核心类设计

#### 2.1.1 基础数据模型

```java
/**
 * 可扩展对象基类
 */
class Extensible {
    String extSchema;                    // 扩展属性schema
    Map<String, String> extAttrs;        // 扩展属性，方便扩展
}

/**
 * 可编程对象基类
 */
class ProgramableObject<T> extends Extensible {
    String code;                         // 对象编码
    String fatherCode;                   // 父对象编码
    T defaultValue;                      // 默认值
    String description;                  // 描述信息
    Integer sortNo;                      // 排序号
}

/**
 * 模块定义
 */
class Module extends ProgramableObject<Integer> {
    Long id = 0L;                        // 版本信息
    String version;                       // 版本号
    ModuleType type;                      // 模块类型：1-General, 4-SET, 8-Template, 16-Tool
    List<Para> paras;                     // 参数列表
    List<Part> parts;                     // 部件列表
    List<Rule> rules;                     // 规则列表
    
    @JsonIgnore
    Map<String, Para> paraMap;            // 参数映射表
    @JsonIgnore
    Map<String, Part> partMap;            // 部件映射表
    @JsonIgnore
    Map<String, Error> errorMap;          // 错误映射表
    
    /**
     * 初始化方法，建立映射关系提升效率
     */
    void init() {
        // 根据paras初始化paraMap
        // 根据parts初始化partMap
        // 根据rules初始化errorMap
    }
}

/**
 * 参数定义
 */
class Para extends ProgramableObject<String> {
    ParaType type;                        // 参数类型：0-枚举, 1-Boolean, 2-Integer, 3-Float, 4-Double, 5-String, 6-Range, 7-日期, 8-多枚举, 10-分组
    List<ParaOption> options;             // 枚举类型下的具体枚举值
    String minValue;                      // Range类型的最小值
    String maxValue;                      // Range类型的最大值
}

/**
 * 参数选项
 */
class ParaOption extends ProgramableObject<String> {
    int codeId;                           // 选项编码ID
}

/**
 * 部件定义
 */
class Part extends ProgramableObject<Integer> {
    PartType type;                        // 部件类型：0-原子Part, 2-Part分类, 3-bundle实例, 10-分组
    Long price;                           // 原子Part的目录价
    Map<String, String> attrs;            // 原子Part的规格属性
    List<AttrSchema> attrSchemas;         // Part分类的规格描述
    
    public Integer getDefaultQuantity() {
        return super.defaultValue;
    }
}

/**
 * 规则定义
 */
class Rule extends Extensible {
    String name;                          // 规则名称
    String progObjType;                   // 可编程对象类型
    String progObjCode;                   // 可编程对象编码
    String progObjField;                  // 可编程对象属性
    String normalNaturalCode;             // 规范化自然语言表示
    String rawCode;                       // 规则原始代码
    String ruleSchemaTypeFullName;        // 规则表达范式类型全名
}
```

#### 2.1.2 规则Schema定义

```java
/**
 * 表达式Schema
 */
class ExprSchema {
    String rawCode;                       // 原始代码
    List<RefProgObjSchema> refProgObjs;   // 引用的编程对象
}

/**
 * 编程对象引用Schema
 */
class RefProgObjSchema {
    String progObjType;                   // 可编程对象类型
    String progObjCode;                   // 可编程对象编码
    String progObjField;                  // 可编程对象属性
}

/**
 * 兼容规则Schema
 */
class CompatiableRuleSchema extends RuleSchema {
    ExprSchema leftExpr;                  // 左表达式
    String operator;                      // 操作符：Incompatible, CoRefent, Requires
    ExprSchema rightExpr;                 // 右表达式
}

/**
 * 选择规则Schema
 */
class SelectRuleSchema extends RuleSchema {
    String type;                          // 筛选类型：single/multiple
    ExprSchema leftExpr;                  // 左表达式
    
    class AssignMapSchema {               // 赋值映射Schema
        ExprSchema leftExpr;              // 左表达式
        String leftAttrCode;              // 左属性编码
        List<RefProgObjSchema> leftRefProgObjs; // 左引用编程对象
    }
}

/**
 * 计算规则Schema
 */
class CalculateRuleSchema extends RuleSchema {
    ExprSchema leftExpr;                  // 左表达式
}
```

#### 2.1.3 算法制品类

```java
/**
 * 约束算法实现基类
 */
class ConstraintAlgImpl {
    // 约束算法的基础实现
}

/**
 * 参数变量
 */
class ParaVar {
    public String code;                   // 参数编码
    public Literal var;                   // 参数值状态
    public BoolVar isHiddenVar;           // 显示隐藏属性
    public Map<Integer, BoolVar> optionSelectVars = Maps.newHashMap(); // 参数可选值的选中状态
}

/**
 * 部件变量
 */
class PartVar {
    public String code;                   // 部件编码
    public IntVar var;                    // 部件的数量值
    public BoolVar isHiddenVar;           // 显示隐藏属性
    public Map<Integer, BoolVar> subPartSelectedVars = Maps.newHashMap(); // 子部件选中状态
}

/**
 * 模块算法制品生成器
 */
class ModuleAlgArtifactGenerator {
    ModuleInfo module;                    // 模块信息
    Map<String, ParaVar> paraMaps;        // 参数映射
    Map<String, PartVar> partMaps;        // 部件映射
    
    /**
     * 构建约束规则
     */
    public void buildConstraintRule(Module module, String path) {
        // 根据Module生成moduleInfo
        ModuleInfo moduleInfo = buildModuleInfo(module);
        // 根据moduleInfo和ModuleConstraintTemplate.ftl，使用freemarker生成算法文件
    }
    
    /**
     * 构建模块信息
     */
    private ModuleInfo buildModuleInfo(Module module) {
        // 根据Module生成ModuleInfo
        // 根据Para生成ParaInfo
        // 根据Part生成PartInfo
        // 调用buildRules生成RuleInfos
    }
    
    /**
     * 构建规则列表
     */
    private List<RuleInfo> buildRules(Module module) {
        // 对每个rules进行处理
    }
    
    /**
     * 构建单个规则
     */
    private RuleInfo buildRule(Module module, Rule rule) {
        // rule基本信息处理
        // 根据ruleSchemaTypeFullName分函数处理
        // CompatiableRule ==> buildCompatiableRule
        // CalculateRule ==> buildCalculateRule
        // SelectRule ==> buildSelectRule
    }
    
    /**
     * 构建兼容规则
     */
    private RuleInfo buildCompatiableRule(RuleInfo ruleInfo, Module module, Rule rule, CompatiableRule ruleSchema) {
        // 处理左表达式
        // 处理右表达式
        // 建立约束关系
    }
    
    /**
     * 选择编程对象
     */
    private Pair<F, List<T>> doSelectProObjs(ExprSchema exprSchema) {
        // 根据exprSchema选择目标对象
        // 调用FilterExpressionExecutor进行过滤
        return Pair<targetObj, filterObjects>;
    }
}

/**
 * 规则信息
 */
class RuleInfo {
    public String code;                   // 规则编码
    public String ruleSchemaTypeFullName; // 规则Schema类型全名
    public String name;                   // 规则名称
    public String normalNaturalCode;      // 自然语言描述
    public String leftTypeName;           // 左类型名称
    public VarInfo left;                  // 左变量信息
    public String rightTypeName;          // 右类型名称
    public VarInfo right;                 // 右变量信息
}

/**
 * 变量信息基类
 */
class VarInfo {
    String varName;                       // 变量名称
}

/**
 * 模块信息
 */
class ModuleInfo extends VarInfo {
    public String code;                   // 模块编码
    public List<ParaInfo> paras;          // 参数信息列表
    public List<PartInfo> parts;          // 部件信息列表
}

/**
 * 参数信息
 */
class ParaInfo extends VarInfo {
    public String code;                   // 参数编码
    public long[] domain;                 // 参数域值
    public List<ParaOptionInfo> options;  // 选项信息列表
}

/**
 * 参数选项信息
 */
class ParaOptionInfo extends VarInfo {
    public int codeId;                    // 选项编码ID
    public String code;                   // 选项编码
}

/**
 * 部件信息
 */
class PartInfo extends VarInfo {
    public String code;                   // 部件编码
    public int maxQuantity = 10000;       // 最大数量
    public int minQuantity = 0;           // 最小数量
}
```

#### 2.1.4 工具类

```java
/**
 * 过滤表达式执行器
 */
class FilterExpressionExecutor {
    /**
     * 根据过滤表达式筛选对象
     */
    List<T> doSelect<T extends Extensible>(List<T> objects, String filterExpr) {
        // 初始化满足过滤条件的对象列表
        // 遍历objects，对每个object执行filterExpr
        // 满足条件的放入到filterObjects
        // 返回filterObjects
    }
}
```

### 2.2 核心流程

#### 2.2.1 模块解析流程

**流程描述**：
1. **输入验证**：验证Module对象的完整性和有效性
2. **基础信息提取**：提取Module的code、version、type等基础属性
3. **参数解析**：遍历paras列表，为每个Para创建ParaInfo对象
4. **部件解析**：遍历parts列表，为每个Part创建PartInfo对象
5. **规则解析**：调用buildRules方法处理rules列表
6. **映射表构建**：建立paraMap、partMap等映射关系
7. **输出ModuleInfo**：返回完整的ModuleInfo对象

**时序图**：
```
ModuleAlgArtifactGenerator -> buildModuleInfo: 调用
buildModuleInfo -> Module: 解析基础信息
buildModuleInfo -> Para: 遍历参数列表
buildModuleInfo -> ParaInfo: 创建参数信息
buildModuleInfo -> Part: 遍历部件列表
buildModuleInfo -> PartInfo: 创建部件信息
buildModuleInfo -> buildRules: 调用规则构建
buildModuleInfo -> ModuleInfo: 返回结果
```

#### 2.2.2 规则解析流程

**流程描述**：
1. **规则遍历**：遍历Module.rules列表中的每个Rule对象
2. **基础信息提取**：提取Rule的code、name、ruleSchemaTypeFullName等属性
3. **Schema类型判断**：根据ruleSchemaTypeFullName字段判断规则类型
4. **分支处理**：
   - CompatiableRule → 调用buildCompatiableRule
   - CalculateRule → 调用buildCalculateRule
   - SelectRule → 调用buildSelectRule
5. **表达式解析**：解析leftExpr和rightExpr
6. **编程对象选择**：调用doSelectProObjs选择目标对象
7. **约束关系建立**：根据规则类型建立相应的约束关系
8. **输出RuleInfo**：返回完整的RuleInfo对象

**时序图**：
```
ModuleAlgArtifactGenerator -> buildRules: 调用
buildRules -> Rule: 遍历规则列表
buildRules -> buildRule: 调用单个规则构建
buildRule -> Rule: 解析规则基础信息
buildRule -> ruleSchemaTypeFullName: 判断规则类型
buildRule -> buildCompatiableRule: 兼容性规则处理
buildRule -> buildCalculateRule: 计算规则处理
buildRule -> buildSelectRule: 选择规则处理
buildRule -> doSelectProObjs: 选择编程对象
buildRule -> RuleInfo: 返回规则信息
```

#### 2.2.3 兼容性规则处理流程

**流程描述**：
1. **左表达式处理**：
   - 调用doSelectProObjs处理leftExpr
   - 根据progObjType、progObjCode、progObjField选择目标对象
   - 执行过滤表达式得到filteredObjects
   - 创建新的变量newLeftVar
2. **右表达式处理**：
   - 调用doSelectProObjs处理rightExpr
   - 执行相同的选择和处理逻辑
   - 创建新的变量newRightVar
3. **约束关系建立**：
   - 根据operator类型建立约束关系
   - Incompatible：建立不兼容约束
   - CoRefent：建立共存性约束
   - Requires：建立依赖约束
4. **变量赋值**：
   - ruleInfo.left = newLeftVar
   - ruleInfo.right = newRightVar

**时序图**：
```
buildCompatiableRule -> doSelectProObjs: 处理左表达式
doSelectProObjs -> FilterExpressionExecutor: 执行过滤
FilterExpressionExecutor -> objects: 筛选对象
doSelectProObjs -> newLeftVar: 创建左变量
buildCompatiableRule -> doSelectProObjs: 处理右表达式
doSelectProObjs -> FilterExpressionExecutor: 执行过滤
FilterExpressionExecutor -> objects: 筛选对象
doSelectProObjs -> newRightVar: 创建右变量
buildCompatiableRule -> ruleInfo: 建立约束关系
```

#### 2.2.4 编程对象选择流程

**流程描述**：
1. **目标对象定位**：
   - 根据exprSchema.progObjType确定业务对象类型
   - 如果progObjType为"Para"，则targetObj = paraMap.get(progObjCode)
   - 如果progObjType为"Part"，则targetObj = partMap.get(progObjCode)
2. **属性字段处理**：
   - 如果progObjField为"options"，则objects = targetObj.getOptions()
   - 如果progObjField为"value"，则objects = targetObj
3. **表达式过滤**：
   - 调用FilterExpressionExecutor.doSelect进行过滤
   - 传入objects和exprSchema.rawCode
   - 返回满足条件的filterObjects
4. **结果返回**：
   - 返回Pair<targetObj, filterObjects>

**详细实现逻辑**：
```java
private <F extends VarInfo, T extends VarInfo> Pair<F, List<T>> doSelectProObjs(ExprSchema exprSchema) {
    // 1. 根据exprSchema的progObjType、progObjCode、progObjField根据待过滤objects
    
    // 根据exprSchema.refProgObjs.progObjType = Para
    // --- 则根据exprSchema.refProgObjs.progObjCode查询参数的options;
    // --- targetObj = paraMap.get(exprSchema.refProgObjs.progObjCode)
    // --- objects = targetObj.getOptions();
    // --- parsedRawCode = replaceToOptionCode(exprSchema.rawCode, from=exprSchema.refProgObjs.progObjCode, to="code")
    //     // 需要将rawcode中 progObjCode替换为code
    
    // 根据exprSchema.refProgObjs.progObjType = Part
    // --- 调用本方法的getChildrenParts(fatherCode); // 根据parts来获取
    // --- targetObj = getPart(code=fatherCode=exprSchema.refProgObjs.progObjCode)
    // --- objects = getChildrenParts(fatherCode=exprSchema.refProgObjs.progObjCode)
    // --- parsedRawCode = parsedRawCode
    
    // 2. 调用FilterExpressionExecutor.doSelect进行过滤
    // filterObjects = FilterExpressionExecutor.doSelect(objects, parsedRawCode)
    
    return Pair<targetObj, filterObjects>;
}
```

**核心处理逻辑**：
1. **Para类型处理**：
   - 从paraMap中获取目标参数对象
   - 获取参数的options列表作为待过滤对象
   - 将rawCode中的progObjCode替换为"code"，因为过滤表达式需要针对option的code字段
   
2. **Part类型处理**：
   - 从partMap中获取目标部件对象
   - 获取子部件列表作为待过滤对象
   - 保持rawCode不变，因为过滤表达式直接针对部件属性

3. **表达式过滤**：
   - 使用FilterExpressionExecutor对objects执行过滤
   - 过滤条件来自exprSchema.rawCode（经过替换处理）
   - 返回满足条件的对象列表

4. **结果封装**：
   - 返回Pair对象，包含目标对象和过滤后的对象列表
   - 支持泛型，F为VarInfo类型，T为VarInfo类型

**时序图**：
```
doSelectProObjs -> exprSchema: 解析表达式Schema
doSelectProObjs -> progObjType: 判断对象类型
doSelectProObjs -> paraMap/partMap: 查找目标对象
paraMap/partMap -> targetObj: 返回目标对象
doSelectProObjs -> targetObj: 获取待过滤对象列表
doSelectProObjs -> rawCode: 处理原始代码
doSelectProObjs -> FilterExpressionExecutor: 执行过滤
FilterExpressionExecutor -> filterExpr: 应用过滤条件
FilterExpressionExecutor -> filterObjects: 返回过滤结果
doSelectProObjs -> Pair: 返回结果对
```

#### 2.2.5 代码生成流程

**流程描述**：
1. **模板数据准备**：
   - 将ModuleInfo转换为模板数据模型
   - 准备paras、parts、rules等数据
2. **FreeMarker模板渲染**：
   - 加载ModuleConstraintTemplate.ftl模板
   - 传入模板数据模型
   - 执行模板渲染
3. **代码文件生成**：
   - 生成Java源代码字符串
   - 写入到指定路径的文件
   - 确保生成的代码可编译

**时序图**：
```
ModuleAlgArtifactGenerator -> FreeMarker: 加载模板
FreeMarker -> ModuleConstraintTemplate.ftl: 读取模板文件
ModuleAlgArtifactGenerator -> ModuleInfo: 准备模板数据
ModuleAlgArtifactGenerator -> FreeMarker: 传入数据模型
FreeMarker -> Template: 渲染模板
Template -> JavaCode: 生成Java代码
ModuleAlgArtifactGenerator -> File: 写入文件
```

#### 2.2.6 过滤表达式执行流程

**流程描述**：
1. **表达式解析**：
   - 解析filterExpr字符串
   - 识别操作符（=、!=、>、<等）
   - 识别字段名和值
2. **对象遍历**：
   - 遍历传入的objects列表
   - 对每个object执行过滤条件
3. **条件判断**：
   - 根据字段名获取对象属性值
   - 执行相应的比较操作
   - 支持扩展属性过滤（attrs字段）
4. **结果收集**：
   - 满足条件的对象加入filterObjects列表
   - 返回过滤后的对象列表

**时序图**：
```
FilterExpressionExecutor -> filterExpr: 解析过滤表达式
FilterExpressionExecutor -> objects: 遍历对象列表
FilterExpressionExecutor -> object: 获取单个对象
FilterExpressionExecutor -> object.attrs: 获取扩展属性
FilterExpressionExecutor -> condition: 执行条件判断
FilterExpressionExecutor -> filterObjects: 收集满足条件的对象
FilterExpressionExecutor -> List: 返回过滤结果
```

### 2.3 流程间关系

**整体流程关系图**：
```
ModuleAlgArtifactGenerator.buildConstraintRule()
    ↓
buildModuleInfo()
    ↓
buildRules() → buildRule() → 具体规则处理方法
    ↓
FreeMarker模板渲染
    ↓
生成Java约束代码文件
```

**关键依赖关系**：
- buildModuleInfo依赖buildRules
- buildRules依赖buildRule
- buildRule依赖具体的规则处理方法
- 所有规则处理方法都依赖doSelectProObjs
- doSelectProObjs依赖FilterExpressionExecutor
- 最终代码生成依赖FreeMarker模板引擎 

## 3. 开发视图

### 3.1 包结构

```
com.jmix.configengine
├── model                    // 数据模型
│   ├── Extensible.java
│   ├── ProgramableObject.java
│   ├── Module.java
│   ├── Para.java
│   ├── Part.java
│   └── Rule.java
├── schema                  // 规则Schema
│   ├── ExprSchema.java
│   ├── RefProgObjSchema.java
│   ├── CompatiableRuleSchema.java
│   ├── SelectRuleSchema.java
│   └── CalculateRuleSchema.java
├── artifact               // 算法制品
│   ├── ConstraintAlgImpl.java
│   ├── ParaVar.java
│   ├── PartVar.java
│   └── ModuleAlgArtifactGenerator.java
├── template               // 模板文件
│   └── ModuleConstraintTemplate.ftl
└── util                   // 工具类
    └── FilterExpressionExecutor.java
```

### 3.2 依赖关系

- 基础模型层：Extensible → ProgramableObject → Module/Para/Part/Rule
- Schema层：RuleSchema → 具体规则Schema
- 制品层：ModuleAlgArtifactGenerator依赖所有模型类
- 工具层：FilterExpressionExecutor独立工具类

## 4. 物理视图

### 4.1 部署架构

- 单机部署，作为代码生成工具
- 支持命令行和API两种调用方式
- 输出为Java源代码文件

### 4.2 技术架构

- 使用Maven进行依赖管理
- 使用FreeMarker进行模板渲染
- 使用OR-Tools进行约束求解

## 5. 场景视图

### 5.1 用例1：T恤配置约束生成

**参与者**：开发人员
**前置条件**：已定义T恤模块的配置参数和约束规则
**主流程**：
1. 调用ModuleAlgArtifactGenerator.buildConstraintRule()
2. 系统解析T恤模块定义
3. 生成TShirtConstraint.java文件
4. 开发人员集成生成的约束代码

**后置条件**：成功生成可运行的约束算法代码

### 5.2 用例2：参数兼容性规则处理

**参与者**：系统
**前置条件**：已定义兼容性规则
**主流程**：
1. 解析兼容性规则Schema
2. 处理左右表达式
3. 建立约束关系
4. 生成对应的约束代码

**后置条件**：生成正确的兼容性约束逻辑

## 6. 数据视图

### 6.1 数据流

1. **输入数据**：Module JSON配置
2. **中间数据**：ModuleInfo、RuleInfo等中间表示
3. **输出数据**：生成的Java约束算法代码

### 6.2 数据转换

- JSON → Java对象 → 中间表示 → 模板数据 → 最终代码

## 7. 约束和限制

### 7.1 技术约束

- 必须使用JDK 8
- 必须使用OR-Tools Java 9.12.4544版本
- 必须使用FreeMarker模板引擎

### 7.2 业务约束

- 保持设计文档中类定义，可以优化但不要大改
- 支持多种规则类型：兼容性、选择、计算等
- 生成的代码必须可编译运行

## 8. 质量属性

### 8.1 可维护性

- 清晰的类层次结构
- 模板与逻辑分离
- 完善的单元测试覆盖

### 8.2 可扩展性

- 支持新的规则类型扩展
- 支持新的参数类型扩展
- 模板化设计便于定制

### 8.3 性能

- 高效的映射表查找
- 最小化对象创建
- 优化的模板渲染

## 9. 风险分析

### 9.1 技术风险

- OR-Tools版本兼容性问题
- 复杂约束规则的正确性验证
- 模板生成的代码质量

### 9.2 缓解措施

- 严格的版本控制
- 完善的测试用例
- 代码审查和验证

## 10. 附录

### 10.1 示例数据

参考原文档中的T恤配置示例数据

### 10.2 模板示例

参考原文档中的ModuleConstraintTemplate.ftl模板

### 10.3 生成代码示例

参考原文档中的TShirtConstraint.java示例代码

## 2. 类结构设计

### 2.1 核心类层次结构

```
VarInfo<T extends Extensible>
├── ModuleInfo extends VarInfo<Module>
├── ParaInfo extends VarInfo<Para>
├── PartInfo extends VarInfo<Part>
└── ParaOptionInfo extends VarInfo<ParaOption>
```

### 2.2 变量类设计

#### 2.2.1 ParaVar（参数变量）
- **用途**：表示参数的状态和选项选择
- **核心字段**：
  - `code`: 参数编码
  - `var`: 参数值状态（Object类型，可转换为IntVar等）
  - `isHiddenVar`: 显示隐藏属性
  - `optionSelectVars`: 参数可选值的选中状态（Map<Integer, ParaOptionInfo>）

#### 2.2.2 PartVar（部件变量）
- **用途**：表示部件的数量和子部件选择状态
- **核心字段**：
  - `code`: 部件编码
  - `var`: 部件的数量值（IntVar类型）
  - `isHiddenVar`: 显示隐藏属性（BoolVar类型）
  - `subPartSelectedVars`: 子部件选中状态（Map<Integer, Object>）

#### 2.2.3 ParaOptionVar（参数选项变量）
- **用途**：表示参数选项的选中状态和相关信息
- **核心字段**：
  - `code`: 参数选项编码
  - `codeId`: 参数选项编码ID
  - `isSelectedVar`: 参数选项的选中状态（BoolVar类型）
  - `isHiddenVar`: 参数选项的显示隐藏属性（BoolVar类型）
  - `quantityVar`: 参数选项的数量值（IntVar类型，支持数量选择）
  - `subOptionSelectedVars`: 子选项选中状态（Map<String, BoolVar>，用于级联选择）

### 2.3 信息类设计

#### 2.3.1 ModuleInfo
- **用途**：模块信息，包含参数、部件和规则的映射
- **核心字段**：
  - `paraMap`: 参数信息映射（Map<String, ParaInfo>）
  - `partMap`: 部件信息映射（Map<String, PartInfo>）
  - `paraMaps`: 参数变量映射（Map<String, ParaVar>）
  - `partMaps`: 部件变量映射（Map<String, PartVar>）

#### 2.3.2 ParaInfo
- **用途**：参数信息，包含选项列表
- **核心字段**：
  - `code`: 参数编码
  - `domain`: 参数域值（long[]）
  - `options`: 选项信息列表（List<ParaOptionInfo>）

#### 2.3.3 PartInfo
- **用途**：部件信息，支持层次结构
- **核心字段**：
  - `code`: 部件编码
  - `fatherCode`: 父部件编码
  - `maxQuantity`: 最大数量
  - `minQuantity`: 最小数量

#### 2.3.4 ParaOptionInfo
- **用途**：参数选项信息
- **核心字段**：
  - `codeId`: 选项编码ID
  - `code`: 选项编码

## 3. 数据流设计

### 3.1 初始化流程

```
Module → ModuleAlgArtifactGenerator → ModuleInfo → ParaVar/PartVar/ParaOptionVar
```

### 3.2 约束生成流程

```
ModuleInfo → Rule → RuleInfo → ConstraintAlgImpl
```

## 4. 核心算法设计

### 4.1 doSelectProObjs方法

```java
private Pair<Object, List<? extends Extensible>> doSelectProObjs(
    ModuleInfo moduleInfo, 
    ExprSchema exprSchema
)
```

**功能**：根据表达式模式选择编程对象

**实现逻辑**：
1. 根据`exprSchema.progObjType`判断对象类型（Para/Part）
2. 根据`exprSchema.progObjCode`查询对应的对象
3. 根据`exprSchema.progObjField`获取待过滤的对象集合
4. 调用`FilterExpressionExecutor.doSelect`进行过滤
5. 返回目标对象和过滤后的对象列表

### 4.2 约束规则构建

#### 4.2.1 兼容性规则（CompatiableRule）
- 支持左右表达式的约束关系
- 使用`doSelectProObjs`方法选择对象
- 支持CoRefent等关系约束

#### 4.2.2 计算规则（CalculateRule）
- 支持数值计算约束
- 支持线性表达式约束

#### 4.2.3 选择规则（SelectRule）
- 支持条件选择约束
- 支持多条件组合

## 5. 使用示例

### 5.1 T恤衫约束示例

```java
public class TShirtConstraint extends ConstraintAlgImpl {
    public ParaVar ColorVar;
    public ParaVar SizeVar;
    public PartVar thsirt11Var;
    public PartVar thsirt12Var;
    
    @Override
    public void initVariables() {
        // 初始化颜色参数（离散值：10, 20, 30）
        this.ColorVar.var = model.newIntVarFromDomain(
            Domain.fromValues(new long[] {10, 20, 30}), "Color");
        
        // 初始化尺寸参数（离散值：1, 2, 3）
        this.SizeVar.var = model.newIntVarFromDomain(
            Domain.fromValues(new long[] {1, 2, 3}), "Size");
    }
    
    @Override
    public void initConstraint() {
        addConstrain_rule1(model, this.ColorVar, this.SizeVar);
        addConstrain_rule2(model, this.thsirt11Var, this.thsirt12Var);
    }
}
```

### 5.2 ParaOptionVar使用示例

```java
// 创建颜色选项变量
ParaOptionVar redOption = new ParaOptionVar("Red", 10, model.newBoolVar("Color_Red"));
ParaOptionVar blueOption = new ParaOptionVar("Blue", 20, model.newBoolVar("Color_Blue"));

// 设置显示隐藏状态
redOption.isHiddenVar = model.newBoolVar("Color_Red_Hidden");
blueOption.isHiddenVar = model.newBoolVar("Color_Blue_Hidden");

// 支持数量选择（如选择多个红色T恤）
redOption.quantityVar = model.newIntVar(0, 10, "Color_Red_Quantity");

// 支持子选项（如红色下的具体色号）
redOption.subOptionSelectedVars.put("DarkRed", model.newBoolVar("Color_Red_DarkRed"));
redOption.subOptionSelectedVars.put("LightRed", model.newBoolVar("Color_Red_LightRed"));
```

## 6. 扩展性设计

### 6.1 新增约束类型
- 继承`ConstraintAlgImpl`类
- 实现`initVariables()`和`initConstraint()`方法
- 在`ModuleAlgArtifactGenerator`中添加对应的构建方法

### 6.2 新增变量类型
- 继承`VarInfo<T>`类
- 在`ModuleAlgArtifactGenerator`中添加对应的构建方法
- 更新相关的映射关系

### 6.3 新增规则类型
- 继承`RuleSchema`类
- 在`ModuleAlgArtifactGenerator`中添加对应的构建方法
- 实现相应的约束逻辑

## 7. 性能优化

### 7.1 映射优化
- 使用`Map<String, T>`进行快速查找
- 在`setParas`和`setParts`时自动更新映射

### 7.2 约束优化
- 使用OR-Tools的CP-SAT求解器
- 支持增量约束添加
- 优化布尔变量和整数变量的使用

## 8. 测试策略

### 8.1 单元测试
- 测试各个类的构造函数和方法
- 测试约束规则的构建逻辑
- 测试变量初始化和约束设置

### 8.2 集成测试
- 测试完整的约束生成流程
- 测试OR-Tools约束求解
- 测试复杂业务场景

### 8.3 性能测试
- 测试大量参数和部件的性能
- 测试复杂约束规则的求解性能
- 测试内存使用情况